// Query Resolvers\nimport { builder } from '../builder'\nimport { ContentFiltersInput, ContentSortBy, SortOrder } from '../types/content'\n\n// User 쿼리들\nbuilder.queryField('user', (t) =>\n  t.prismaField({\n    type: 'User',\n    nullable: true,\n    args: {\n      id: t.arg.string(),\n      slug: t.arg.string(),\n    },\n    resolve: async (query, _, { id, slug }, { prisma }) => {\n      if (!id && !slug) {\n        throw new Error('Either id or slug must be provided')\n      }\n      \n      return await prisma.user.findUnique({\n        ...query,\n        where: id ? { id } : { slug }\n      })\n    }\n  })\n)\n\nbuilder.queryField('users', (t) =>\n  t.prismaConnection({\n    type: 'User',\n    cursor: 'id',\n    resolve: async (query, _, __, { prisma }) => {\n      return await prisma.user.findMany({\n        ...query,\n        where: {\n          isDeleted: false\n        },\n        orderBy: {\n          createdAt: 'desc'\n        }\n      })\n    }\n  })\n)\n\n// Provider 쿼리들\nbuilder.queryField('provider', (t) =>\n  t.prismaField({\n    type: 'Provider',\n    nullable: true,\n    args: {\n      id: t.arg.string(),\n      slug: t.arg.string(),\n    },\n    resolve: async (query, _, { id, slug }, { prisma }) => {\n      if (!id && !slug) {\n        throw new Error('Either id or slug must be provided')\n      }\n      \n      return await prisma.provider.findUnique({\n        ...query,\n        where: id ? { id } : { slug }\n      })\n    }\n  })\n)\n\nbuilder.queryField('providers', (t) =>\n  t.prismaConnection({\n    type: 'Provider',\n    cursor: 'id',\n    args: {\n      isVerified: t.arg.boolean(),\n    },\n    resolve: async (query, _, { isVerified }, { prisma }) => {\n      return await prisma.provider.findMany({\n        ...query,\n        where: {\n          ...(isVerified !== undefined && { isVerified }),\n        },\n        orderBy: {\n          createdAt: 'desc'\n        }\n      })\n    }\n  })\n)\n\n// Content 쿼리들\nbuilder.queryField('content', (t) =>\n  t.prismaField({\n    type: 'Content',\n    nullable: true,\n    args: {\n      id: t.arg.int(),\n      slug: t.arg.string(),\n    },\n    resolve: async (query, _, { id, slug }, { prisma, user }) => {\n      if (!id && !slug) {\n        throw new Error('Either id or slug must be provided')\n      }\n      \n      const content = await prisma.content.findUnique({\n        ...query,\n        where: id ? { id } : { slug }\n      })\n      \n      // 조회수 증가 (같은 사용자의 중복 조회 방지)\n      if (content && user) {\n        const existingView = await prisma.userInteraction.findUnique({\n          where: {\n            userId_contentId_type: {\n              userId: user.id,\n              contentId: content.id,\n              type: 'VIEW'\n            }\n          }\n        })\n        \n        if (!existingView) {\n          await prisma.$transaction([\n            prisma.userInteraction.create({\n              data: {\n                userId: user.id,\n                contentId: content.id,\n                type: 'VIEW'\n              }\n            }),\n            prisma.content.update({\n              where: { id: content.id },\n              data: {\n                viewCount: {\n                  increment: 1\n                }\n              }\n            })\n          ])\n        }\n      }\n      \n      return content\n    }\n  })\n)\n\nbuilder.queryField('contents', (t) =>\n  t.prismaConnection({\n    type: 'Content',\n    cursor: 'id',\n    args: {\n      filters: t.arg({ type: ContentFiltersInput }),\n      sortBy: t.arg({ type: ContentSortBy }),\n      sortOrder: t.arg({ type: SortOrder }),\n    },\n    resolve: async (query, _, { filters, sortBy, sortOrder }, { prisma }) => {\n      const where: any = {}\n      \n      if (filters) {\n        if (filters.status) where.status = filters.status\n        if (filters.categoryId) where.categoryId = filters.categoryId\n        if (filters.authorId) where.authorId = filters.authorId\n        if (filters.providerId) where.providerId = filters.providerId\n        if (filters.isFeatured !== undefined) where.isFeatured = filters.isFeatured\n        if (filters.isHero !== undefined) where.isHero = filters.isHero\n        if (filters.tags && filters.tags.length > 0) {\n          where.contentTags = {\n            some: {\n              tag: {\n                slug: {\n                  in: filters.tags\n                }\n              }\n            }\n          }\n        }\n        if (filters.search) {\n          where.OR = [\n            {\n              title: {\n                contains: filters.search,\n                mode: 'insensitive'\n              }\n            },\n            {\n              contentBody: {\n                contains: filters.search,\n                mode: 'insensitive'\n              }\n            }\n          ]\n        }\n      }\n      \n      // 기본값: 발행된 콘텐츠만 조회\n      if (!where.status) {\n        where.status = 'PUBLISHED'\n      }\n      \n      const orderBy: any = {}\n      if (sortBy && sortOrder) {\n        const sortKey = sortBy.toLowerCase()\n        orderBy[sortKey === 'created_at' ? 'createdAt' : \n                sortKey === 'updated_at' ? 'updatedAt' :\n                sortKey === 'published_at' ? 'publishedAt' :\n                sortKey === 'view_count' ? 'viewCount' :\n                sortKey === 'like_count' ? 'likeCount' : 'title'] = sortOrder.toLowerCase()\n      } else {\n        orderBy.publishedAt = 'desc'\n      }\n      \n      return await prisma.content.findMany({\n        ...query,\n        where,\n        orderBy\n      })\n    }\n  })\n)\n\n// Category 쿼리들\nbuilder.queryField('category', (t) =>\n  t.prismaField({\n    type: 'Category',\n    nullable: true,\n    args: {\n      id: t.arg.int(),\n      slug: t.arg.string(),\n    },\n    resolve: async (query, _, { id, slug }, { prisma }) => {\n      if (!id && !slug) {\n        throw new Error('Either id or slug must be provided')\n      }\n      \n      return await prisma.category.findUnique({\n        ...query,\n        where: id ? { id } : { slug }\n      })\n    }\n  })\n)\n\nbuilder.queryField('categories', (t) =>\n  t.prismaField({\n    type: ['Category'],\n    args: {\n      isVisible: t.arg.boolean(),\n    },\n    resolve: async (query, _, { isVisible }, { prisma }) => {\n      return await prisma.category.findMany({\n        ...query,\n        where: {\n          ...(isVisible !== undefined && { isVisible }),\n        },\n        orderBy: {\n          sortOrder: 'asc'\n        }\n      })\n    }\n  })\n)\n\n// Tag 쿼리들\nbuilder.queryField('tag', (t) =>\n  t.prismaField({\n    type: 'Tag',\n    nullable: true,\n    args: {\n      id: t.arg.int(),\n      slug: t.arg.string(),\n    },\n    resolve: async (query, _, { id, slug }, { prisma }) => {\n      if (!id && !slug) {\n        throw new Error('Either id or slug must be provided')\n      }\n      \n      return await prisma.tag.findUnique({\n        ...query,\n        where: id ? { id } : { slug }\n      })\n    }\n  })\n)\n\nbuilder.queryField('tags', (t) =>\n  t.prismaField({\n    type: ['Tag'],\n    args: {\n      tagType: t.arg.string(),\n      search: t.arg.string(),\n      limit: t.arg.int(),\n    },\n    resolve: async (query, _, { tagType, search, limit }, { prisma }) => {\n      const where: any = {}\n      \n      if (tagType) where.tagType = tagType\n      if (search) {\n        where.name = {\n          contains: search,\n          mode: 'insensitive'\n        }\n      }\n      \n      return await prisma.tag.findMany({\n        ...query,\n        where,\n        orderBy: {\n          usageCount: 'desc'\n        },\n        take: limit || undefined\n      })\n    }\n  })\n)\n\n// Comment 쿼리들\nbuilder.queryField('comments', (t) =>\n  t.prismaConnection({\n    type: 'Comment',\n    cursor: 'id',\n    args: {\n      contentId: t.arg.int({ required: true }),\n      parentCommentId: t.arg.int(),\n    },\n    resolve: async (query, _, { contentId, parentCommentId }, { prisma }) => {\n      return await prisma.comment.findMany({\n        ...query,\n        where: {\n          contentId,\n          parentCommentId: parentCommentId || null,\n          isDeleted: false\n        },\n        orderBy: {\n          createdAt: 'asc'\n        }\n      })\n    }\n  })\n)\n\n// Banner 쿼리들\nbuilder.queryField('banners', (t) =>\n  t.prismaField({\n    type: ['Banner'],\n    args: {\n      location: t.arg.string(),\n      isActive: t.arg.boolean(),\n    },\n    resolve: async (query, _, { location, isActive }, { prisma }) => {\n      const where: any = {}\n      \n      if (location) where.location = location\n      if (isActive !== undefined) where.isActive = isActive\n      \n      // 현재 활성화된 배너만 (시작일/종료일 고려)\n      const now = new Date()\n      where.OR = [\n        { startDate: null },\n        { startDate: { lte: now } }\n      ]\n      where.AND = [\n        {\n          OR: [\n            { endDate: null },\n            { endDate: { gte: now } }\n          ]\n        }\n      ]\n      \n      return await prisma.banner.findMany({\n        ...query,\n        where,\n        orderBy: {\n          sortOrder: 'asc'\n        }\n      })\n    }\n  })\n)\n